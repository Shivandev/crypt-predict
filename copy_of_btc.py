# -*- coding: utf-8 -*-
"""Copy of btc.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GHNvvMTOQMy3cwKSItMepL7l-j0ztbGB
"""

!pip install yfinance matplotlib pandas numpy tensorflow plotly

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

# Download Bitcoin price data from Yahoo Finance
bitcoin_data = yf.download('BTC-USD', start='2023-01-01', end='2025-03-11', progress=False)

# Display the data
bitcoin_data.head()

# Extract the closing prices
closing_prices = bitcoin_data['Close'].values
closing_prices = closing_prices.reshape(-1, 1)

# Normalize the data to be between 0 and 1
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(closing_prices)

# Create the training dataset
training_data_len = int(np.ceil(0.8 * len(scaled_data)))
train_data = scaled_data[0:training_data_len, :]

X_train = []
y_train = []

for i in range(60, len(train_data)):
    X_train.append(train_data[i-60:i, 0])  # 60 previous days for predicting
    y_train.append(train_data[i, 0])  # Next day's closing price

X_train, y_train = np.array(X_train), np.array(y_train)

# Reshaping X_train to be compatible with LSTM input format
X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))

from tensorflow.keras import layers

# Create the LSTM model
model = Sequential()

# Add the first LSTM layer with the correct input shape
model.add(layers.InputLayer(shape=(X_train.shape[1], 1)))  # Replace input_shape with shape

# Add the first LSTM layer with return_sequences=True
model.add(LSTM(units=50, return_sequences=True))

# Add the second LSTM layer
model.add(LSTM(units=50, return_sequences=False))

# Add a Dense layer with 25 units
model.add(Dense(units=25))

# Add the output layer with 1 unit (predicting the price)
model.add(Dense(units=1))

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(X_train, y_train, batch_size=1, epochs=1)

# Create the test data set (20% of data for testing)
test_data = scaled_data[training_data_len - 60:, :]
X_test = []
y_test = closing_prices[training_data_len:, :]

for i in range(60, len(test_data)):
    X_test.append(test_data[i-60:i, 0])  # 60 previous days for prediction

X_test = np.array(X_test)

# Reshaping X_test to be compatible with LSTM input
X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))

# Predict the price using the trained model
predictions = model.predict(X_test)

# Inverse transform predictions to get the actual predicted price values
predictions = scaler.inverse_transform(predictions)

# Plotting the results
train = bitcoin_data[:training_data_len]
valid = bitcoin_data[training_data_len:]
valid['Predictions'] = predictions

plt.figure(figsize=(16,8))
plt.title('Bitcoin Price Prediction')
plt.plot(train['Close'], label='Training Data')
plt.plot(valid['Close'], label='Actual Price')
plt.plot(valid['Predictions'], label='Predicted Price')
plt.legend()
plt.show()

!pip install flask

from flask import Flask, render_template
import os
import matplotlib.pyplot as plt
import numpy as np
import yfinance as yf
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras import layers

app = Flask(__name__)

@app.route('/')
def home():
    # Download Bitcoin data
    bitcoin_data = yf.download('BTC-USD', start='2023-01-01', end='2025-01-01', progress=False)
    closing_prices = bitcoin_data['Close'].values
    closing_prices = closing_prices.reshape(-1, 1)

    # Normalize data
    scaler = MinMaxScaler(feature_range=(0, 1))
    scaled_data = scaler.fit_transform(closing_prices)

    # Split data for training and testing
    training_data_len = int(np.ceil(0.8 * len(scaled_data)))
    train_data = scaled_data[0:training_data_len, :]
    X_train, y_train = [], []

    for i in range(60, len(train_data)):
        X_train.append(train_data[i-60:i, 0])
        y_train.append(train_data[i, 0])

    X_train, y_train = np.array(X_train), np.array(y_train)
    X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))

    # Build the model
    model = Sequential()
    model.add(layers.InputLayer(shape=(X_train.shape[1], 1)))
    model.add(LSTM(units=50, return_sequences=True))
    model.add(LSTM(units=50, return_sequences=False))
    model.add(Dense(units=25))
    model.add(Dense(units=1))
    model.compile(optimizer='adam', loss='mean_squared_error')
    model.fit(X_train, y_train, batch_size=1, epochs=1)

    # Prepare testing data
    test_data = scaled_data[training_data_len - 60:, :]
    X_test = []
    for i in range(60, len(test_data)):
        X_test.append(test_data[i-60:i, 0])

    X_test = np.array(X_test)
    X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))

    # Predict prices
    predictions = model.predict(X_test)
    predictions = scaler.inverse_transform(predictions)

    # Plotting the data
    train = bitcoin_data[:training_data_len]
    valid = bitcoin_data[training_data_len:]
    valid['Predictions'] = predictions

    # Plot the graph
    plt.figure(figsize=(16,8))
    plt.title('Bitcoin Price Prediction')
    plt.plot(train['Close'], label='Training Data')
    plt.plot(valid['Close'], label='Actual Price')
    plt.plot(valid['Predictions'], label='Predicted Price')
    plt.xlabel('Date')
    plt.ylabel('Bitcoin Price (USD)')
    plt.legend()
    plt.grid(True)

    # Save plot as image
    plot_path = '/content/bitcoin_price_prediction.png'
    plt.savefig(plot_path)
    plt.close()

    return render_template('index.html', plot_url=plot_path)

if __name__ == '__main__':
    app.run(debug=True, use_reloader=False)

!pip install graphviz

import graphviz

# Create a flowchart
flowchart = graphviz.Digraph(comment='Bitcoin Price Prediction Workflow')

# Define nodes
flowchart.node('A', 'Start')
flowchart.node('B', 'Collect Historical Bitcoin Data')
flowchart.node('C', 'Preprocessing: Normalize, Clean, Feature Selection')
flowchart.node('D', 'Train Model (RNN/LSTM)')
flowchart.node('E', 'Make Predictions')
flowchart.node('F', 'Evaluate Model Performance')
flowchart.node('G', 'Output: Future Bitcoin Prices')
flowchart.node('H', 'End')

# Define edges between nodes to represent the flow
flowchart.edge('A', 'B')
flowchart.edge('B', 'C')
flowchart.edge('C', 'D')
flowchart.edge('D', 'E')
flowchart.edge('E', 'F')
flowchart.edge('F', 'G')
flowchart.edge('G', 'H')

# Render and display the flowchart
flowchart.render('bitcoin_price_prediction_flowchart', format='png', view=True)

import shutil
shutil.move('bitcoin_price_prediction_flowchart_horizontal.png', '/content/bitcoin_price_prediction_flowchart_horizontal.png')